\documentclass[../../../../../main]{subfiles}

\begin{document}
    \subsubsubsection{イベント数とメモリ使用量の関係}\label{subsubsec:result-streaming-only-limit-memory}

    イベント数の増加に対するメモリ使用量の推移を記す。図\ref{fig:stream-memory-app_1_1024-db_1_1024}に実験結果を示す。

    \subfile{図:stream-memory-app_1_1024-db_1_1024/図:stream-memory-app_1_1024-db_1_1024}

    図\ref{fig:stream-memory-app_1_1024-db_1_1024}から、アプリケーションサーバーのメモリ使用量がイベント数が0から4万程度まではあまり変わらず、4万から75万程度まではイベント数にメモリ使用量が比例し、75万以降は一定になっている。この75万以降のメモリ使用量は1024MBであり、コンテナに設定されたメモリ上限に張り付いている状態であった。

    ストリーミング処理では、ORMモデルにデコードされたレコードから順に処理していくため、アプリケーションサーバーのメモリ使用量は最低限であると予想していたがメモリ使用量はおおよそ比例していた。この原因を追求するため、アプリケーションサーバーからDBサーバーへ発行されるクエリをログから確認したところ図\ref{fig:streaming-query}のようになっていた。

    \subfile{図:ストリーミング処理で発行されるクエリ/図:ストリーミング処理で発行されるクエリ}
    
    そしてユーザーのイベント数100万件の状態に対してクエリを実行したところ、\texttt{1064.019 ms}でクエリが実行された。しかし、100万件の際のサーバー内処理時間は\texttt{31.19914698600769sec}であるため、クエリ実行時間は0.03\%ほどであった。このことから、クエリ実行時間はサーバー内処理時間に対して無視できるほど小さいことがわかる。そのためサーバー内処理時間の大半は集計処理に当てられており、集計後のレコードのメモリはすぐに解放されるはずであるため、ORMのデコードに時間とメモリを要していると推測する。

    また、CPUやレスポンス時間から推測されたボトルネックの出現はメモリにあるという説が有力になる。

\end{document}