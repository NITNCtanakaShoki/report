\documentclass[../../../main]{subfiles}

\begin{document}
    \subsection{イベントソーシング}\label{subsec:phraseology-event_sourcing}
    イベントソーシング\cite{DB指向イベントソーシング}は, ドメイン駆動設計（Domain-Driven Design, DDD）のコミュニティにおいて開発された手法である. この手法は, アプリケーションの状態に加えられたすべての変更を, 変更イベントのログとして保存することを特徴とする. これは, 変更データキャプチャ（Change Data Capture, CDC）に似ているが, イベントソーシングでは, これをより抽象化し, 異なるレベルで適用することが求められる.

    具体的には, イベントソーシングでは, アプリケーションのロジックがイミュータブル（不変）なイベントとしてイベントログに記録され, その基盤上に構築される. イベントストアにおいては, 追記のみが行われ, 更新や削除は抑制される, または禁止される. このアプローチにより, イベントはアプリケーションレベルで起こったことを反映するように設計される. したがって, ユーザーのアクションをミュータブルなデータベースに記録するのではなく, イミュータブルなイベントとして記録することが, より有意義とされる.

    イベントソーシングは, アプリケーションの進化を容易にし, 発生した事象の理由を後から理解しやすくすることでデバッグを支援し, バグに対する保護を提供する. 例えば, 「学生が講義への参加をキャンセルした」というイベントを保存することは, 講義への参加状況の更新やキャンセル理由の追加といった副作用よりも, アクションの流れを自然かつ明確に表現する. 新しい機能が導入された際にも, イベントソーシングは新しい副作用を既存のイベントから容易に分離できる.

    イベントソーシングは, 時系列データモデルや, スタースキーマにおけるイベントログとファクトテーブルのような時点に似ている. この手法を支援するためには, Event Storeのような専門化されたデータベースが開発されているが, このアプローチは任意の特定ツールから独立している. 従来のデータベースやログベースのメッセージブローカーでも, このスタイルでのアプリケーション構築が可能である.

    重要な点は, イベントログ自体は特に役立つわけではなく, ユーザーが必要とするのはシステムの変更履歴ではなく, 現在の状態であるということである. イベントソーシングを利用するアプリケーションは, イベントログをアプリケーションの状態に変換し, ユーザーに適した形で提示する. この変換には任意のロジックを用いることができるが, 一貫してイベントログから同じアプリケーションの状態を導出できるように, このロジックは決定的であるべきである. 変更データキャプチャの場合と同様に, イベントログをリプレイすればシステムの現在の状態を再構築できるが, ログのコンパクションは異なる扱いが必要である.

    一般的に, イベントソーシングを利用するアプリケーションは, イベントログから導出された現在の状態のスナップショットを保存する仕組みを持っており, ログ全体を繰り返し処理する必要はない. ただし, これは読み取りやクラッシュからのリカバリのためのパフォーマンスの最適化に過ぎない. システムはすべての生のイベントを恒久的に保存し, 必要に応じて完全なイベントログを再処理できるように設計されている.

    イベントソーシングの哲学は, イベントとコマンドを慎重に区別している. ユーザーからのリクエストが来た時点ではそれはコマンドであり, 何らかの整合性の条件に違反する可能性があるため, 失敗することもある. アプリケーションはコマンドを実行できるかどうかを検証しなければならず, その検証に成功し, コマンドが受け付けられたら, そのコマンドはイベントとなる. イベントは永続性を持ち, イミュータブルであるため, 一度生成されるとそれは事実となる. イベントストリームのコンシューマはイベントを拒否することができず, コンシューマに見えた時点でそのイベントはログの不変な部分となり, 他のコンシューマからもすでに見られている可能性がある. したがって, コマンドに対する検証は, そのコマンドがイベントになる前に動機的に行われなければならない. これには, アトミックにコマンドを検証してイベントを公開するような直列化可能なトランザクションが利用されることがある.
\end{document}