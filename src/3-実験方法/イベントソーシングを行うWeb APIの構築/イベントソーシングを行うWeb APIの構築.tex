\documentclass[../../../main]{subfiles}

\begin{document}
    \subsection{イベントソーシングを行うWeb APIの構築}\label{subsec:method-event_sourcing_api}

    本研究では, イベントソーシングを活用したWeb APIサーバーをSwift言語で構築する. Swiftは自動参照カウント（ARC）機能を採用しているため, 不要になったメモリは自動的に解放される. これにより, メモリ使用量を正確に計測することが可能である.

    このWeb APIサーバーは, ユーザー間でポイントを取引し, ユーザーのポイントを確認できる機能を持つ. イベントソーシングで実装されるため, 取引をイベントとしてRelational DatabaseであるPostgreSQLに保存される. 保存されたイベントを, 記録順に取引を処理していくことで現在のユーザーのポイントを導出する. 取引順である必要性はないもののイベントソーシングでは, イベントの発生順に従って処理を行うことが一般的であるために, 本研究でもこのような実装を採用する.

    \paragraph{対象ドメインの説明}
    本研究で扱うサービスは、特定のアプリケーションやサービスを想定していない。むしろ、過去のすべてのイベントを発生順にアプリケーションサーバーで集約する必要がある一般的なドメインを対象としている。具体的には、ユーザー間のポイント取引イベントを例に、ユーザーからユーザーへのポイント移動をイベントとして扱い、これらのイベントを順に処理して最終的なユーザーのポイント数を集計する。このアプローチは、多種多様なアプリケーションやサービスでの応用が可能であり、イベントソーシングの実装とパフォーマンス評価における一般的な基盤を提供する。

    サーバーサイドフレームワークとしては, Vaporを採用し, ORMにはFluentを使用する. 以下に, イベントソーシングを行うWeb APIサーバーのテーブル定義を示す.

    \subfile{コード:WebAPIのテーブル定義/コード:WebAPIのテーブル定義}

    ユーザーと取引イベントが一対多の関係になっている. 取引の発生時刻は\texttt{send\_events}の\texttt{date}カラムに記録され, その値が同一である場合は\texttt{UUID}である\texttt{id}カラムが小さい方が先に発生したイベントとして処理を行う.

    INDEXは削除して計測するパターンも用意したが, それ以外の計測の際には以下の定義を使用する.

    \subfile{コード:WebAPIのINDEX定義/コード:WebAPIのINDEX定義}

    イベント集計方法としては, 5つの異なるアプローチを用意する. これらはストリーミング処理, チャンク処理, OFFSETを用いたページング処理, ページ末イベントを利用したページング処理, 並行化したページ末イベントを利用したページング処理である.

    イベント集計方法には以下の5つのアプローチが含まれる.

    1. \textbf{ストリーミング処理}：この方法では, 各イベントがデータベースから取得し, ORMによってモデルに変換されるたびに, 即座に集計処理が行われる. このアプローチでは, メモリ使用量が最も少ないと予想されるが, イベントの数が多い場合, 処理時間が長くなる可能性がある.

    2. \textbf{チャンク処理}：チャンク処理では, イベントを一定のグループ（チャンク）に分けてから処理を行う. チャンクの大きさによって, メモリ使用量と処理速度が変化する. チャンクサイズを大きくするほど, メモリ使用量は増加するが, 処理速度が向上することが予想される. 本実験では, 10, 100, 1000, 10000のイベント件数のチャンクパターンで計測を行う.

    3. \textbf{OFFSETでのページング処理}：この方法では, SQLのOFFSETとLIMITを用いてページング処理を行う. ページング処理は, 一定数のイベントを処理し終えた後に次の一定数のイベントを取得し, これを繰り返す. この方法は, チャンク処理やストリーミング処理に比べて処理速度が遅いと予想されるが, メモリ使用量はチャンク処理に近いと考えられる.

    4. \textbf{ページ末イベントを利用したページング処理}：この方法では, 各ページ末のイベント作成日とIDを利用して, WHERE節でデータを絞り込んだ後にLIMITでページングを行う. このアプローチは, OFFSETを使用する方法に比べてデータベースの処理速度が向上することが期待されるが, コードの複雑性は増す.

    5. \textbf{並行化したページ末イベントを利用したページング処理}：この方法では, 集計処理中に次の集計分のイベントを並行で取得する. これにより, 処理時間の短縮が期待されるが, メモリ使用量は増加する可能性がある. また, 並行処理の実装によりコードの複雑性がさらに増す.

    これらの集計方法を用いて, イベントソーシングのイベント件数とパフォーマンスの相関を詳細に分析する. Web APIサーバーのリソース制限はDockerを使用して設定し, CPUとメモリの使用量を様々な設定で実験する.

    それぞれの集計方法において使用されるSQLを示す. \textbf{ストリーミング処理}と\textbf{チャンク処理}においては以下のSQLが使用される.

    \subfile{コード:streamとchunkのSQL/コード:streamとchunkのSQL}

    ポイントを取得したいユーザーが送金先または送金者である取引イベントに絞り込み, 取引の発生順に並び替えて取得する. WHERE句でORを使用しているため, INDEXの効果が得られづらく, UNION ALLを利用してより効率的なSQLを構築することも可能であるが, イベントの重複の可能性があり整合性を保証できないため, 本研究では使用しない.

    \textbf{OFFSETでのページング処理}においては以下のSQLが使用される.

    \subfile{コード:paging-offsetのSQL/コード:paging-offsetのSQL}

    このSQLでは, 図\ref{fig:streaming-chunk-sql}と違い, LIMIT句とOFFSET句が使用されており, OFFSETでのページング処理を行っている. 何番目から何番目の項目を取得するかを指定して取得するページング処理によく使用される. INDEXの効果は得られるものの, OFFSETの値が大きくなるほど処理速度が低下するという問題がある.

    \textbf{ページ末イベントを利用したページング処理}と\textbf{並行化したページ末イベントを利用したページング処理}においては以下のSQLが使用される.

    \subfile{コード:paging-lastのSQL/コード:paging-lastのSQL}

    このSQLでは, 図\ref{fig:paging-offset-sql}と違い, OFFSETがなく, 代わりにWHERE句を使用している. WHERE区で前ページの最後のイベントの日付とidよりも後のイベントに絞り込むことでOFFSETが不要になる. この方法では, OFFSETを使用する方法に比べてデータベースの処理速度が向上することが期待されるが, 前ページの最後のイベントを記録しておく必要があり, コードの複雑性が増す.


\end{document}